#!/usr/bin/env ruby

# Command line client for scalariver
# Takes a file name, issues an HTTP request to the server
# and prints the formatted scala source to stdout
# Usage: scalariver path/to/File.scala

require 'net/https'
require 'uri'
require 'optparse'

# To use your own scalariver instance:
# export SCALARIVER_URL="http://my-scalariver-instance"
SCALARIVER_URL = URI(ENV.key?("SCALARIVER_URL") ? URI(ENV["SCALARIVER_URL"]) : "http://river.scalex.org")
USER_AGENT = "Scalariver CLI"

def http_connection(uri)
  env = ENV['http_proxy'] || ENV['HTTP_PROXY']
  connection = if env
                 proxy = URI(env)
                 Net::HTTP::Proxy(proxy.host, proxy.port).new(uri.host, uri.port)
               else
                 Net::HTTP.new(uri.host, uri.port)
               end
  if uri.scheme == "https"
    connection.use_ssl = true
    connection.verify_mode = OpenSSL::SSL::VERIFY_NONE
  end
  connection.open_timeout = 5
  connection.read_timeout = 5
  connection
end

def http(url, request)
  request['User-Agent'] = USER_AGENT
  http_connection(url).start do |http|
    http.request request
  end
rescue Timeout::Error
  raise "Could not connect to #{url}"
end

options = {}
opts = OptionParser.new do |opts|
  [
    [nil, 'stdin', "Read Scala source from standard input"],
    [nil, 'stdout', "Write the formatted output to standard output"],
    ['f', 'forceOutput', "If using --stdout, print the source unchanged if it cannot be parsed correctly."],
    ['q', 'quiet', "Work quietly"]
  ].each do |arr|
    opts.on(arr[0] == nil ? nil : '-' + arr[0], "--#{arr[1]}", arr[2]) do
      options[arr[1]] = true
    end
  end
  # [
  #   ['rewriteArrowSymbols', "Replace arrow tokens with unicode equivalents"],
  #   ['alignParameters', "Align parameters on different lines in the same column"]
  # ].each do |arr|
  #   [["+", "Enable", true], ["-", "Disable", false]].each do |brr|
  #     opts.on(brr[0] + arr[0], brr[1] + " " + arr[1]) do
  #       options[arr[0]] = brr[2]
  #     end
  #   end
  # end
end
opts.parse!

if options['stdin']
  source = STDIN.read
else
  if ARGV.empty?
    raise ArgumentError, "No file! Use --stdin to read from input"
  else
    source_file = File.expand_path(ARGV[0])
    source = File.read(source_file)
  end
end

request = Net::HTTP::Post.new("/")
params = options
params['source'] = source
request.set_form_data(params)
response = http(SCALARIVER_URL, request)
case response.code
when "200"
  print response.body if options['stdout']
  if source != response.body and !options['stdout']
    File.open(source_file, 'w') do |f|
      f.write response.body
    end
    print "Reformated #{source_file}" if !options['quiet']
  end
else
  print response.body if options['stdout'] and options['forceOutput']
  $stderr.puts response.body if $stdin.tty?
end
